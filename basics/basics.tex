\documentclass{beamer}

\input{../shared/rust-slides-style.tex}

\title{Rust Basics}

\begin{document}
\begin{frame}
  \titlepage{}
\end{frame}

\section{Variables}
\begin{frame}[fragile]
  \frametitle{Assigning Variable}
  Rust uses the \inlinecode{let} keyword to assign/bind a value to a variable. The general format for assigning a variable is as follows:

\begin{lstlisting}[mathescape=true, language=Rust]
let $\textit{variable\_{}name}$: $\textit{type}$ = $\textit{value}$;
\end{lstlisting}

  Examples:
  \lstinputlisting[language=Rust]{variable_assignment1.rs}

  Variables are valid within the scope of a block. A block is anything within braces \inlinecode{\{\}}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Assigning Variable}
  Often times, the Rust compiler can infer the type of the varible during compile time. Therefore specifying the type is not always nessary.
  \lstinputlisting[language=Rust]{variable_assignment2.rs}

  The compiler can also infer the type when the variable is declared first and then assign the a value at a later time. Just make sure a value is assigned to it before using it.
  \lstinputlisting[language=Rust]{variable_assignment3.rs}
\end{frame}

\begin{frame}
  \frametitle{Mutability and Variables}
  By default, Rust variables are not mutable (cannot change). This is to help programmers to take advantage of Rust's safety and easy concurrency.
  \lstinputlisting{variable_mutability1.rs}

  To make a variable mutable, use the \inlinecode{mut} keyword after the \inlinecode{let} keyword.
  \lstinputlisting{variable_mutability2.rs}
\end{frame}

\begin{frame}
  \frametitle{Variable Shadowing}
  When two variables of the same name is declared, the second declared variable would be used by the compiler instead of the first one. This is called ``Variable Shadowing''.
  \lstinputlisting{variable_shadowing1.rs}

  This is different from making a variable mutable as the shadowed variable can be of a different type. (Rust is a static typed language)
\end{frame}

\begin{frame}
  \frametitle{Variable Shadowing}
  This two examples shows the difference between mutable variables and variable shadowing when assigning an integer first and a string slice later.
  \lstinputlisting[caption=Comiple Error]{variable_shadowing2.rs}
  \lstinputlisting[caption=No Compile Error]{variable_shadowing3.rs}
\end{frame}

\begin{frame}
  \frametitle{Constants}
  Constants are immutable variable and cannot be used with the \inlinecode{mut} keyword. It can be declared in any scope including the global scope. It is also valid for the entire runtime of the program and must be a constant expression (cannot be computed at runtime).
  \lstinputlisting{constants.rs}
\end{frame}

\begin{frame}
  \frametitle{Statics}
  Statics are simillar to constants. Static variables are valid for the entire lifetime of the program. Unlike constants, static variables can be mutable but accessing a mutable static variable requires it to be in an \inlinecode{unsafe} block. Static variables can be created by using the \inlinecode{'static} lifetime or string literals (any strings created by `` '') are always static variables.
  \lstinputlisting{statics.rs}
\end{frame}

\section{Printing}
\begin{frame}
  \frametitle{println/print macro}
  Rust provides macros to help with printing to the standard output. In previous slides, the \inlinecode{println} macro is used, this macro would print the formatted string into the standard output.
  \lstinputlisting[caption={Prints `Hello, world!' to standard output}]{println1.rs}
  The \inlinecode{print} macro is simillar to \inlinecode{println} except it doesn't print a new line after the string.

  \alert{Note:} Macro calls are different than functions calls talked in future chapter. Macro calls have an ``!'' at the end of the macro name.
\end{frame}

\begin{frame}
  \frametitle{Printing Variables}
  Strings can be formatted to print variables.
  \lstinputlisting{println2.rs}
  There are also formatting options to control how the variable displayed such as controlling it's alignment and width the variable will take up.
  \lstinputlisting[caption={Prints the variable to be center aligned and 10 characters wide}]{println3.rs}
\end{frame}

\begin{frame}
  \frametitle{Print to Standard Error}
  Rust provides macros to print to standard error as well. This is achived by using the \inlinecode{eprint} and \inlinecode{eprintln} macro. The syntax is simillar to the \inlinecode{print} and \inlinecode{println} macro.
  \lstinputlisting{eprintln.rs}
\end{frame}

\section{Primitive Types}
\subsection{Scalar Types}
\begin{frame}
  \frametitle{Integers}
  There are two types of integers. Both of them have options with different sizes.

  Unsigned Integers:
  \begin{itemize}
    \item[u8]{Unsigned 8-bit integer}
    \item[u16]{Unsigned 16-bit integer}
    \item[u32]{Unsigned 32-bit integer}
    \item[u64]{Unsigned 64-bit integer}
    \item[u128]{Unsigned 128-bit integer}
    \item[usize]{The pointer-sized unsigned integer type. (32-bit in 32-bit targets and 64-bit in 64-bit targets.)}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Integers}
  Signed Integers:
  \begin{itemize}
    \item[i8]{Signed 8-bit integer}
    \item[i16]{Signed 16-bit integer}
    \item[i32]{Signed 32-bit integer}
    \item[i64]{Signed 64-bit integer}
    \item[i128]{Signed 128-bit integer}
    \item[isize]{The pointer-sized signed integer type. (32-bit in 32-bit targets and 64-bit in 64-bit targets.)}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Floating Point Numbers}
  There are two floating points numbers types. \inlinecode{f32} is a 32-bit floating point type and \inlinecode{f64} is a 64-bit floating point type.

  Both the floating points number follows the IEEE 754--2008 standard. \inlinecode{f32} follows the ``binary32'' format and \inlinecode{f64} follows the ``binary64'' format.
  \lstinputlisting{float.rs}
\end{frame}

\begin{frame}
  \frametitle{Boolean}
  The \inlinecode{bool} type is a type that can be either \inlinecode{true} or \inlinecode{false}.
  \lstinputlisting{bool.rs}
  \alert{Notice} that boolean numbers can be represented as integers. A boolean value of \inlinecode{true} would be 1 and a boolean value of \inlinecode{false} would be 0.
\end{frame}

\begin{frame}
  \frametitle{Characters}
  The \inlinecode{char} type represents a single character. However, unlike C \inlinecode{char}, Rust \inlinecode{char} supports Unicode characters more specifically a \href{https://www.unicode.org/glossary/\#unicode_scalar_value}{Unicode scalar value} is considered a character.

  Since Unicode is supported your favorite emoji works in Rust.
  \lstinputlisting[caption=See Source File on GitHub for the Correct Emojis]{char.rs}
\end{frame}

\subsection{Compound Types}
\begin{frame}
  \frametitle{Arrays}
\end{frame}

\begin{frame}
  \frametitle{Slices}
\end{frame}

\begin{frame}
  \frametitle{Tuples and Tuple Destruction}
  % Tuple being Hetrogeneous
  % Indexing
  % Destructing
\end{frame}

\section{Functions}
\begin{frame}
  \frametitle{Declaring Functions}
\end{frame}

\begin{frame}
  \frametitle{Function Parameters}
\end{frame}

\begin{frame}
  \frametitle{Function Returns}
\end{frame}

\begin{frame}
  \frametitle{Function Returns}
  % Expressions and Statements (;)
\end{frame}

\section{Control Flow}
\subsection{If Else}
\begin{frame}
  \frametitle{Using Ifs}
\end{frame}

\begin{frame}
  \frametitle{Else If and Else}
\end{frame}

\begin{frame}
  \frametitle{If Else with let}
\end{frame}

\subsection{Loops}
\begin{frame}
  \frametitle{\inlinecode{loop} Keyword}
  % General Syntax
  % Loop Labesl
  % Returning Values
\end{frame}

\begin{frame}
  \frametitle{While Loops}
\end{frame}

\begin{frame}
  \frametitle{For Loops}
  % collections (arrays)
\end{frame}

\section{Comments}
\begin{frame}
  \frametitle{Comments}
\end{frame}

% All of the following is optional and typically not needed.
\appendix
\section<presentation>*{\appendixname}
\subsection<presentation>*{Additional Resources}
\begin{frame}[allowframebreaks]
   \href{https://doc.rust-lang.org/std/fmt/index.html}{More Formatting Options}

   \href{https://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008 Standard}
\end{frame}
\end{document}
