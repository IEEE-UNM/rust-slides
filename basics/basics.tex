\documentclass{beamer}

\input{../shared/rust-slides-style.tex}

\title{Rust Basics}

\begin{document}
\begin{frame}
  \titlepage{}
\end{frame}

\section{Variables}
\begin{frame}[fragile]
  \frametitle{Assigning Variable}
  Rust uses the \inlinecode{let} keyword to assign/bind a value to a variable. The general format for assigning a variable is as follows:

\begin{lstlisting}[mathescape=true, language=Rust]
let $\textit{variable\_{}name}$: $\textit{type}$ = $\textit{value}$;
\end{lstlisting}

  Exmaples:
  \lstinputlisting[language=Rust]{variable_assignment1.rs}

  Variables are valid within the scope of a block. A block is anything within braces \inlinecode{\{\}}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Assigning Variable}
  Often times, the Rust compiler can infer the type of the varible during compile time. Therefore specifying the type is not always nessary.
  \lstinputlisting[language=Rust]{variable_assignment2.rs}

  The compiler can also infer the type when the variable is declared first and then assign the a value at a later time. Just make sure a value is assigned to it before using it.
  \lstinputlisting[language=Rust]{variable_assignment3.rs}
\end{frame}

\begin{frame}
  \frametitle{Mutability and Variables}
  By default, Rust variables are not mutable (cannot change). This is to help programmers to take advantage of Rust's safety and easy concurrency.
  \lstinputlisting{variable_mutability1.rs}

  To make a variable mutable, use the \inlinecode{mut} keyword after the \inlinecode{let} keyword.
  \lstinputlisting{variable_mutability2.rs}
\end{frame}

\begin{frame}
  \frametitle{Variable Shadowing}
  When two variables of the same name is declared, the second declared variable would be used by the compiler instead of the first one. This is called ``Variable Shadowing''.
  \lstinputlisting{variable_shadowing1.rs}

  This is different from making a variable mutable as the shadowed variable can be of a different type. (Rust is a static typed language)
\end{frame}

\begin{frame}
  \frametitle{Variable Shadowing}
  This two examples shows the difference between mutable variables and variable shadowing when assigning an integer first and a string slice later.
  \lstinputlisting[caption=Comiple Error]{variable_shadowing2.rs}
  \lstinputlisting[caption=No Compile Error]{variable_shadowing3.rs}
\end{frame}

\begin{frame}
  \frametitle{Constants}
  Constants are immutable variable and cannot be used with the \inlinecode{mut} keyword. It can be declared in any scope including the global scope. It is also valid for the entire runtime of the program and must be a constant expression (cannot be computed at runtime).
  \lstinputlisting{constants.rs}
\end{frame}

\begin{frame}
  \frametitle{Statics}
  Statics are simillar to constants. Static variables are valid for the entire lifetime of the program. Unlike constants, static variables can be mutable but accessing a mutable static variable requires it to be in an \inlinecode{unsafe} block. Static variables can be created by using the \inlinecode{'static} lifetime or string literals (any strings created by `` '') are always static variables.
  \lstinputlisting{statics.rs}
\end{frame}

\section{Printing}
\begin{frame}
  \frametitle{println macro}
\end{frame}

\begin{frame}
  \frametitle{Printing Variables}
\end{frame}

\begin{frame}
  \frametitle{Print to Standard Error}
\end{frame}

\section{Primitive Types}
\subsection{Scalar Types}
\begin{frame}
  \frametitle{Integers}
\end{frame}

\begin{frame}
  \frametitle{Floating Point Numbers}
\end{frame}

\begin{frame}
  \frametitle{Boolean}
\end{frame}

\begin{frame}
  \frametitle{Characters}
\end{frame}

\subsection{Compound Types}
\begin{frame}
  \frametitle{Arrays}
\end{frame}

\begin{frame}
  \frametitle{Slices}
\end{frame}

\begin{frame}
  \frametitle{Tuples and Tuple Destruction}
  % Tuple being Hetrogeneous
  % Indexing
  % Destructing
\end{frame}

\section{Functions}
\begin{frame}
  \frametitle{Declaring Functions}
\end{frame}

\begin{frame}
  \frametitle{Function Parameters}
\end{frame}

\begin{frame}
  \frametitle{Function Returns}
\end{frame}

\begin{frame}
  \frametitle{Function Returns}
  % Expressions and Statements (;)
\end{frame}

\section{Control Flow}
\subsection{If Else}
\begin{frame}
  \frametitle{Using Ifs}
\end{frame}

\begin{frame}
  \frametitle{Else If and Else}
\end{frame}

\begin{frame}
  \frametitle{If Else with let}
\end{frame}

\subsection{Loops}
\begin{frame}
  \frametitle{\inlinecode{loop} Keyword}
  % General Syntax
  % Loop Labesl
  % Returning Values
\end{frame}

\begin{frame}
  \frametitle{While Loops}
\end{frame}

\begin{frame}
  \frametitle{For Loops}
  % collections (arrays)
\end{frame}

\section{Comments}
\begin{frame}
  \frametitle{Comments}
\end{frame}

% All of the following is optional and typically not needed.
\appendix
\section<presentation>*{\appendixname}
\subsection<presentation>*{Additional Resources}
\end{document}
